# 通用经验

1. memset(a,0,sizeof(a)); //数组的初始化。一般定义一个数组都要初始化 数组定义int a[10] 为全局变量的话，其全部元素默认赋值为0；整型数据默认为0，字符串默认为空。

2. #define max 0x0ffffff; //max 为正无穷 

3. #define min -0x0ffffff; 

4. 多组测试数据使用 while(n--){ 程序 } 

5. 一般用C语言节约空间，要用C++库函数或STL时才用C++; cout、cin和printf、scanf最好不要混用。而且需要注意的是，如果题目是大规模数据的输入输出，尽量使用printf和scanf，数据量一大，速度明显比c++的输入输出快。 输出1000000个数据，cout 大概用6s printf 用了0.562s 

6. 有时候int型不够用，可以用long long或__int64型(两个下划线__)。 值类型表示值介于 -2^63 ( -9,223,372,036,854,775,808) 到2^63-1(+9,223,372,036,854,775,807 )之间的整数。 printf("%I64d",a); printf("%lld",a); 

7. OJ判断是只看输出结果的。 所以大部分题处理一组数据后可以直接输出，就不需要用数组保存每一个Case的数据。

8. 纯字符串用puts()输出，会增快速度。 

9. 先用scanf()，再用gets()会读入回车。

10. scanf("%c%c",&c1,&c2) 后者会读入空格和回车；要使用getchar()吸收空格和回车的录入，使用c语言读字符和字符串一定要十分小心。尽量写好就自己输出一下看看是否是自己需要的值被读入。 

11. 读到文件的结尾，程序自动结束 

    ```C
    while( ( scanf(“%d”,&a) ) != -1 )
    while( ( scanf(“%d”,&a) ) != EOF) 
    ```

    while( ( scanf(“%d”,&a) ) == 1 ) 

    读到一个0时，程序结束 

    ```C
    while( scanf(“%d”,&a) &&a) 
    ```

    读到多个0时，程序结束 

    ```C
    while( scanf(“%d%d%d”,&a,&b,&c)&&a+b+c )
    ```

    

    该方法不能读取负值。

12. 圆周率=cos(-1.0) 自然对数=exp(1.0)

13. 如果要乘或除2^n,用位移运算速度快。

        a>>n;a<<n; 如：求n^m 时间复杂度log(m) int calc(int n,int m){ int re=1; while(m){ if(m&1) re*=n; n*=n; m>>=1; } return re; } 

14. 定义数组时，数组大小最好比告诉的最大范围大一点。字符数组大小必须比字符串最大长度大1。

15. 习惯使用三目运算符 int max(int a,int b){return a>b?a:b;} int gcd(int m,int n){return n?gcd(n,m%n):m;} int abs(int a){return a<0?-a:a;} 

16. 有的题数据范围小但是计算量大可以用打表法，先把结果算出来保存在数组里，要用时直接取出来。 

17. 大概的计算自己程序的时间的方法：引入头文件：#include<time.h> 主函数末尾添加上一句cout<<(double)clock()/CLOCKS_PER_SEC;但是输入必需重定向，不然会计算输入数据等待时间。

18. runtimeerror 一般这种错误都是下标越界或者是未赋值的变量就直接使用这两种情况，一定要好好排查，不仔细一般找不出来。另外还有在函数内开了一个比较大的数组，使堆栈耗尽所以出错。

19. 字符串str，其实也不需要strlen(str)，可以写for(int i = 0; str[i];i++)

20. 多个case的情况要记得在每个case之前初始化全局变量。

    ```c
    memset(dfn, 0, sizeof(dfn));
    cnt = 0;
    ```


# 按知识点分类

## 线性表

* 大整数乘法
  * 先不管进位，用数组实现，算完之后再算进位
* 约瑟夫问题：41人站成一圈，报到3的自杀。求活的那个人的编号。n个人，报到m的时候自杀。
  * 循环链表模拟
  * 递推公式：
    * 每死一个人重新从1开始报数，也就是重新编号。
    * f(k)表示最终活下来那个人，在还剩k个人的时候的编号。
    * 边界条件f(1) = 0;
    * 递推关系：f(k) = (f(k-1) + m) % k
      * 循环队列，肯定有求余的操作
      * f(k)是还剩k个人的编号，当然要除k求余数。

## 动态规划

* 找到子问题：
  * 构造状态转移方程的时候可以考虑简单的分类，分成可以约化得更简单的子问题
* 实现。
* 过桥问题：最后一个人是否是最后一个过桥。是=贪心；不是=化归成等价于n和n-1两个人最后一起过去。
* POJ 1088 滑雪，简单的搜索
* POJ 2727 节省空间的动态规划

## 并查集

* 基本操作：
  * **Merge：**将两个等价类放到一起
  * **FindRoot：**判断两个元素是否等价
  * 并查集主要用于解决**等价类**的问题。
* 并查集的题目要点：
  * 理解集合的划分（不一定按照题目的意思），例如：是否有病；是否为关系已知的集合
  * 维护与各个节点相关的量的数组
    * 量的选择：简单一些，这样的话可以用来计算复杂量：例如维护与父节点的关系（简单）——维护与根节点的关系（复杂）
* POJ 1611
* POJ 1988
* POJ2492 &1192

## 树状数组

* 树状数组基本概念：
  * lowbit(x)
  * **区间更新**
  * **区间查询**
  * 把数组按2的幂次分成不同的区间，可以完成**区间更新**和**区间查询**的任务

* 要点：
  * 根据原来的数组Array（或者没有原来的数组也可以）构造C
  * 判断区间特性（例如最大值）与子区间特性的关系（例如$S_{n:m} = S_{1:m}-S_{1:(n-1)}$，S代表求和）
  * 更新C和查询区间特性

* AppleTree:

  * 注意用DFS给树节点编号（Tarjan中也常用）**开始时间和结束时间的理解**

  * ```cpp
    update(start[idx])//而不是update(idx)
    ```

* LIS:

  * 但好麻烦
  * 有一个基于贪心的：尽可能小地加大LIS最后一个元素的值。

## 线段树

* 线段树基本概念：

  * 区间分解：要注意mid=(a+b)/2去尾取整，所以右子树开头是mid+1而不是mid。边界的判断不要搞错

* 要实现的操作：建立、更新、查找

  * ```cpp
    void buildTree(int root,int left,int right);
    void Update(int root, int s, int e, int updateVal);
    void Query(int root ,int s ,int e)
    ```

* 技巧：

  * 考虑每个节点要存放的信息；
    * sum和inc
  * 如何进行高效率的更新；
    * 不需要一更新就更新到叶子节点——延迟更新。

* POJ 3438

  * 简单模板题目，单点更新=区间长度为1的区间更新

* POJ 3243

  * 区间更新题目

* POJ 2182 Lost Cows

  * 牛的编号=原来的值；牛在现在队列中的编号的序号（例如，1,3,5,6，那么序号分别是1,2,3,4）=离散化之后的值。

  * 利用线段树做离散化：1 3 4 5 7 -> 1 2 3 4 5 

  * ```cpp
    struct node{
        int l,r;
        int pl,pr;
        int len;//原来数值[l,r]区间里有的元素数为len，初始值为r-l+1
    }
    ```


## Trie图

* 注意可以通过插入的方式把模式串插入，不需要单独存模式串

## 图连通性Tarjan算法

* 

  * 图的连通性，可以用邻接表的方式存图

    ```c
    vector<int> G[nodesNum];
    for nodes u in V and (u,v) in E:
    	G[u].push_back(v);
    ```

  * 合并连通分量的时候可以用“染色”的方法。给每个点一个color的属性。然后检查每个边的两端是否不同颜色。

  * 强连通分量合点的时候要注意**重边**

    ```cpp
    set<int> G[nodesNum];
    ```

* 容易错的地方在与处理重边。

* 大坑题目：曹操的桥。

  * 权重为0的边需要输出结果1（题目的实际背景）
  * 判断无向图是否连通：只需要做一次DFS，如果最后一个填入的dfn值和|V|（定点数）不同，那么则不是连通图。
  * 无向图如果能出现重边，重边一定不是桥。在这一题中，把模板中“判断v==father”，也就是DFS不能回到父节点这个要求，改成"Edge.id != fatherEdge.id"，也就是不能从来的边回去。

## 网络流

* 用邻接矩阵代码更方便
* Dinic算法
  * 先做BFS给每层编号
  * 然后DFS：
    * 查到终止节点的层就停
    * 查到终止节点就开始退栈。记得存储最“底层”的“瓶颈”的位置
  * 直到做不了BFS才停

# 按题目编号

* POJ 1611:
  * 集合合并
* POJ 1988：
  * 题目明确表示不考虑两个同堆的方块merge到一起
* POJ 2492 & 1192
  * 食物链和同性恋的虫子
  * 可传递的二元关系，在树结构上可以维护它和父节点的关系
  * 这样可以计算它和任意节点的关系
  * 读数据要把一组读完，不要轻易用break。
* POJ 1088
  * 算法简单
  * 注意memset是逐个字节替换的。可以有0,和-1大整数乘法大，但是set成1会出错
* POJ 2727
  * 01背包问题
  * 可以使用一维数组，节省空间。
* POJ 3438 
  * 注意数组编号和区间起始终止是没有关系的两套系统，不要搞混（0开头还是1开头）
* POJ 3187 ACM Factory
  * 实现的时候注意把同一个机器的节点**拆开**
  * 可以用一个规模为2*MAXN的矩阵。
