# LIS 树状数组解法

原来的数组叫做a，现在试图在a中找到LIS。

使用动态规划可以有O(n^2)的算法，要求按照a的顺序从头到尾读数，每次读一个数要比较能不能和前面所有的LIS接在一起。可以看见这个解法多次查找了“前面”这个区间的信息O(n)。我们可以用树状数组查找信息O(logn)这个性质加快这个解法。

用树状数组的经验：1.考虑要用的区间性质，构造一个树状数组C[i]和S[i]；2.考虑如何根据C得到性质

## 定义树状数组

定义C[i]为<u>**终点位于**</u>a[i-lowbit(i)+1]到a[i]里面（包括两端）LIS的长度。

定义LIS[i]以**终点位于**a[1]-a[i]的LIS的长度。

## 如何得到性质LIS[i]

我们得考虑如何由C[i]得到LIS[i]：

LIS[i] = max(C[i])

## 如何构造C

可以一轮一轮地更新C。

但是由于有一个上升的要求，所以得从小的数开始往上读。

给a进行排序，得到n，同时维护一个n中每个元素原本在a中的位置的列表。

初始化：把所有的C[i]和LIS[i]设置为0

从n的第一个开始读，读到最后一个：

* 读n[1]的时候，它一定可以成为LIS的终点，所以得更新带n[1]的所有C[i] +1，LIS[n[1].pos] = 1
* 读n[k]的时候，它前面的k-1个数字都比它小。
  * 原数组a中，在它前面的LIS（长度为LIS(n[k].pos)）的终点元素一定比它小（因为读的顺序由小到大），所以它肯定可以加上去。故LIS[n[k].pos] = LIS(n[k].pos-1)+1
  * 同样，因为n[k]是目前读到的数里面最大的，所有带n[k]的C[i]都得更新
* 查询的环节query(k)表示a[1]-a[k]\(包括两端)LIS长度。

问题：如果a中出现了相同的元素怎么办？

* 要求：更新LIS的时候里面不可以有跟n[k]相同的元素，也就是原数组中，位置n[k].pos之前不能够有和n[k]相同的元素。
* 那倒过来读就可以了，也就是如果有相同的元素，在n中，就按照pos的大小，由大到小排。
* 为什么合理呢？
  * 首先这样做满足上面的“要求”。
  * 更新LIS的时候没有问题。
  * 更新C[i]的时候，更新了LIS之后再更新C，由于满足了上述要求，LIS的终点一定是n[i].pos对应的那个元素，那么C[i]和LIS[i]应该做一个比较，如果LIS更大，那就更新C[i]；否则说明C[i]管辖的范围内存在k,LIS[k]>C[i]
  * 也就是说，合理。